import {MermaidDiagram} from '@/components/MermaidDiagram';

# Alerting and Incident Response

Effective alerting and incident response systems ensure rapid detection, notification, and resolution of data pipeline issues. This involves intelligent alert management, escalation procedures, and automated response mechanisms to minimize downtime and data quality issues.

## Alerting and Incident Response Architecture

<MermaidDiagram chart={`
graph TB
    subgraph "Monitoring Sources"
        MS1[Pipeline Monitors]
        MS2[Data Quality Checks]
        MS3[System Metrics]
        MS4[Business Metrics]
    end
    
    subgraph "Alert Processing"
        AP1[Alert Rules Engine]
        AP2[Severity Classification]
        AP3[Deduplication]
        AP4[Correlation]
    end
    
    subgraph "Notification System"
        NS1[Email Alerts]
        NS2[Slack/Teams]
        NS3[PagerDuty]
        NS4[SMS/Phone]
    end
    
    subgraph "Incident Management"
        IM1[Incident Creation]
        IM2[Escalation]
        IM3[Response Coordination]
        IM4[Resolution Tracking]
    end
    
    subgraph "Response Actions"
        RA1[Automated Remediation]
        RA2[Runbook Execution]
        RA3[Rollback Procedures]
        RA4[Manual Intervention]
    end
    
    MS1 --> AP1
    MS2 --> AP2
    MS3 --> AP3
    MS4 --> AP4
    
    AP1 --> NS1
    AP2 --> NS2
    AP3 --> NS3
    AP4 --> NS4
    
    NS1 --> IM1
    NS2 --> IM2
    NS3 --> IM3
    NS4 --> IM4
    
    IM1 --> RA1
    IM2 --> RA2
    IM3 --> RA3
    IM4 --> RA4
    
    style MS1 fill:#e3f2fd
    style AP1 fill:#e8f5e8
    style NS1 fill:#fff3e0
    style IM1 fill:#f3e5f5
    style RA1 fill:#fce4ec
`} />

## Alert Management System

### Core Alert Framework

```python
# Comprehensive Alerting System
import smtplib
import requests
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from enum import Enum
import uuid
import logging
from collections import defaultdict
from email.mime.text import MIMEText

class AlertSeverity(Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"

class AlertStatus(Enum):
    """Alert status"""
    ACTIVE = "active"
    ACKNOWLEDGED = "acknowledged"
    RESOLVED = "resolved"
    SUPPRESSED = "suppressed"

@dataclass
class AlertRule:
    """Alert rule definition"""
    rule_id: str
    name: str
    description: str
    condition: str
    severity: AlertSeverity
    threshold_value: float
    comparison_operator: str  # >, <, >=, <=, ==, !=
    evaluation_window_minutes: int = 5
    cooldown_minutes: int = 15
    enabled: bool = True
    
    def evaluate(self, current_value: float) -> bool:
        """Evaluate if alert condition is met"""
        if not self.enabled:
            return False
        
        operators = {
            '>': lambda x, y: x > y,
            '<': lambda x, y: x < y,
            '>=': lambda x, y: x >= y,
            '<=': lambda x, y: x <= y,
            '==': lambda x, y: x == y,
            '!=': lambda x, y: x != y
        }
        
        op_func = operators.get(self.comparison_operator)
        return op_func(current_value, self.threshold_value) if op_func else False

@dataclass
class Alert:
    """Alert instance"""
    alert_id: str
    rule_id: str
    title: str
    description: str
    severity: AlertSeverity
    status: AlertStatus
    created_at: datetime
    updated_at: datetime
    resolved_at: Optional[datetime] = None
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None
    current_value: Optional[float] = None
    threshold_value: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def acknowledge(self, user: str):
        """Acknowledge the alert"""
        self.status = AlertStatus.ACKNOWLEDGED
        self.acknowledged_at = datetime.now()
        self.acknowledged_by = user
        self.updated_at = datetime.now()
    
    def resolve(self):
        """Resolve the alert"""
        self.status = AlertStatus.RESOLVED
        self.resolved_at = datetime.now()
        self.updated_at = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'alert_id': self.alert_id,
            'rule_id': self.rule_id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.value,
            'status': self.status.value,
            'created_at': self.created_at.isoformat(),
            'current_value': self.current_value,
            'threshold_value': self.threshold_value,
            'acknowledged_by': self.acknowledged_by
        }

class NotificationChannel:
    """Base class for notification channels"""
    
    def __init__(self, name: str, config: Dict[str, Any]):
        self.name = name
        self.config = config
        self.logger = logging.getLogger(__name__)
    
    def send_notification(self, alert: Alert) -> bool:
        """Send notification for alert"""
        raise NotImplementedError

class EmailNotificationChannel(NotificationChannel):
    """Email notification channel"""
    
    def send_notification(self, alert: Alert) -> bool:
        """Send email notification"""
        try:
            from_email = self.config.get('from_email', 'alerts@company.com')
            to_emails = self.config.get('to_emails', [])
            
            if not to_emails:
                return False
            
            subject = f"[{alert.severity.value.upper()}] {alert.title}"
            body = f"""
Alert Details:
- Alert ID: {alert.alert_id}
- Severity: {alert.severity.value.upper()}
- Description: {alert.description}
- Created: {alert.created_at}
- Current Value: {alert.current_value}
- Threshold: {alert.threshold_value}
            """
            
            # In real implementation, would send actual email
            self.logger.info(f"Email notification sent for alert {alert.alert_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to send email notification: {e}")
            return False

class SlackNotificationChannel(NotificationChannel):
    """Slack notification channel"""
    
    def send_notification(self, alert: Alert) -> bool:
        """Send Slack notification"""
        try:
            webhook_url = self.config.get('webhook_url')
            if not webhook_url:
                return False
            
            colors = {
                AlertSeverity.INFO: '#36a64f',
                AlertSeverity.WARNING: '#ff9500',
                AlertSeverity.CRITICAL: '#ff0000',
                AlertSeverity.EMERGENCY: '#8B0000'
            }
            
            payload = {
                'attachments': [{
                    'color': colors.get(alert.severity, '#36a64f'),
                    'title': f"{alert.severity.value.upper()}: {alert.title}",
                    'text': alert.description,
                    'fields': [
                        {'title': 'Alert ID', 'value': alert.alert_id, 'short': True},
                        {'title': 'Current Value', 'value': str(alert.current_value), 'short': True}
                    ]
                }]
            }
            
            # In real implementation, would make actual HTTP request
            self.logger.info(f"Slack notification sent for alert {alert.alert_id}")
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to send Slack notification: {e}")
            return False

class AlertManager:
    """Main alert management system"""
    
    def __init__(self):
        self.rules: Dict[str, AlertRule] = {}
        self.active_alerts: Dict[str, Alert] = {}
        self.alert_history: List[Alert] = []
        self.notification_channels: Dict[str, NotificationChannel] = {}
        self.cooldown_tracker: Dict[str, datetime] = {}
        self.logger = logging.getLogger(__name__)
    
    def add_rule(self, rule: AlertRule):
        """Add alert rule"""
        self.rules[rule.rule_id] = rule
        self.logger.info(f"Added alert rule: {rule.name}")
    
    def add_notification_channel(self, channel: NotificationChannel):
        """Add notification channel"""
        self.notification_channels[channel.name] = channel
        self.logger.info(f"Added notification channel: {channel.name}")
    
    def evaluate_rules(self, metrics: Dict[str, float]) -> List[Alert]:
        """Evaluate all rules against current metrics"""
        triggered_alerts = []
        
        for rule_id, rule in self.rules.items():
            # Check cooldown
            if rule_id in self.cooldown_tracker:
                cooldown_end = self.cooldown_tracker[rule_id] + timedelta(minutes=rule.cooldown_minutes)
                if datetime.now() < cooldown_end:
                    continue
            
            # Get metric value
            metric_value = metrics.get(rule.condition)
            if metric_value is None:
                continue
            
            # Evaluate condition
            if rule.evaluate(metric_value):
                # Check if alert already exists
                existing_alert = None
                for alert in self.active_alerts.values():
                    if alert.rule_id == rule_id and alert.status == AlertStatus.ACTIVE:
                        existing_alert = alert
                        break
                
                if not existing_alert:
                    # Create new alert
                    alert = Alert(
                        alert_id=str(uuid.uuid4()),
                        rule_id=rule_id,
                        title=rule.name,
                        description=rule.description,
                        severity=rule.severity,
                        status=AlertStatus.ACTIVE,
                        created_at=datetime.now(),
                        updated_at=datetime.now(),
                        current_value=metric_value,
                        threshold_value=rule.threshold_value
                    )
                    
                    self.active_alerts[alert.alert_id] = alert
                    self.alert_history.append(alert)
                    triggered_alerts.append(alert)
                    
                    # Set cooldown
                    self.cooldown_tracker[rule_id] = datetime.now()
                    
                    # Send notifications
                    self._send_notifications(alert)
                    
                    self.logger.warning(f"Alert triggered: {alert.title}")
        
        return triggered_alerts
    
    def acknowledge_alert(self, alert_id: str, user: str) -> bool:
        """Acknowledge an alert"""
        if alert_id in self.active_alerts:
            alert = self.active_alerts[alert_id]
            alert.acknowledge(user)
            self.logger.info(f"Alert {alert_id} acknowledged by {user}")
            return True
        return False
    
    def resolve_alert(self, alert_id: str) -> bool:
        """Resolve an alert"""
        if alert_id in self.active_alerts:
            alert = self.active_alerts[alert_id]
            alert.resolve()
            del self.active_alerts[alert_id]
            self.logger.info(f"Alert {alert_id} resolved")
            return True
        return False
    
    def get_active_alerts(self, severity: AlertSeverity = None) -> List[Alert]:
        """Get active alerts, optionally filtered by severity"""
        alerts = list(self.active_alerts.values())
        if severity:
            alerts = [a for a in alerts if a.severity == severity]
        return sorted(alerts, key=lambda x: x.created_at, reverse=True)
    
    def get_alert_statistics(self) -> Dict[str, Any]:
        """Get alert statistics"""
        total_alerts = len(self.alert_history)
        active_count = len(self.active_alerts)
        
        severity_counts = defaultdict(int)
        for alert in self.alert_history:
            severity_counts[alert.severity.value] += 1
        
        # Calculate resolution times
        resolved_alerts = [a for a in self.alert_history if a.resolved_at]
        avg_resolution_time = 0
        if resolved_alerts:
            resolution_times = [
                (a.resolved_at - a.created_at).total_seconds() / 60
                for a in resolved_alerts
            ]
            avg_resolution_time = sum(resolution_times) / len(resolution_times)
        
        return {
            'total_alerts': total_alerts,
            'active_alerts': active_count,
            'alerts_by_severity': dict(severity_counts),
            'average_resolution_time_minutes': avg_resolution_time,
            'notification_channels': len(self.notification_channels),
            'alert_rules': len(self.rules)
        }
    
    def _send_notifications(self, alert: Alert):
        """Send notifications for alert"""
        for channel_name, channel in self.notification_channels.items():
            try:
                success = channel.send_notification(alert)
                if success:
                    self.logger.info(f"Notification sent via {channel_name}")
            except Exception as e:
                self.logger.error(f"Error sending notification via {channel_name}: {e}")

# Example usage
def example_alerting_system():
    """Example of alerting system"""
    
    # Initialize alert manager
    alert_manager = AlertManager()
    
    # Add notification channels
    email_channel = EmailNotificationChannel('email', {
        'from_email': 'alerts@company.com',
        'to_emails': ['oncall@company.com']
    })
    
    slack_channel = SlackNotificationChannel('slack', {
        'webhook_url': 'https://hooks.slack.com/services/YOUR/WEBHOOK'
    })
    
    alert_manager.add_notification_channel(email_channel)
    alert_manager.add_notification_channel(slack_channel)
    
    # Add alert rules
    cpu_rule = AlertRule(
        rule_id='cpu_high',
        name='High CPU Usage',
        description='CPU usage is above 80%',
        condition='cpu_percent',
        severity=AlertSeverity.WARNING,
        threshold_value=80.0,
        comparison_operator='>'
    )
    
    error_rate_rule = AlertRule(
        rule_id='error_rate_high',
        name='High Error Rate',
        description='Pipeline error rate is above 5%',
        condition='error_rate_percent',
        severity=AlertSeverity.CRITICAL,
        threshold_value=5.0,
        comparison_operator='>'
    )
    
    alert_manager.add_rule(cpu_rule)
    alert_manager.add_rule(error_rate_rule)
    
    # Simulate metric evaluation
    print("=== ALERTING SIMULATION ===")
    
    # Normal metrics - no alerts
    normal_metrics = {
        'cpu_percent': 45.0,
        'error_rate_percent': 1.2
    }
    
    alerts = alert_manager.evaluate_rules(normal_metrics)
    print(f"Normal metrics: {len(alerts)} alerts triggered")
    
    # Critical metrics - multiple alerts
    critical_metrics = {
        'cpu_percent': 95.0,
        'error_rate_percent': 8.5
    }
    
    alerts = alert_manager.evaluate_rules(critical_metrics)
    print(f"Critical metrics: {len(alerts)} alerts triggered")
    
    # Get statistics
    stats = alert_manager.get_alert_statistics()
    print(f"\nAlert Statistics:")
    print(f"  Total alerts: {stats['total_alerts']}")
    print(f"  Active alerts: {stats['active_alerts']}")
    print(f"  By severity: {stats['alerts_by_severity']}")
    
    # Show active alerts
    active_alerts = alert_manager.get_active_alerts()
    print(f"\nActive Alerts:")
    for alert in active_alerts:
        print(f"  {alert.severity.value.upper()}: {alert.title}")
    
    # Acknowledge and resolve
    if active_alerts:
        first_alert = active_alerts[0]
        alert_manager.acknowledge_alert(first_alert.alert_id, "oncall_engineer")
        alert_manager.resolve_alert(first_alert.alert_id)
        print(f"\nResolved alert: {first_alert.title}")
    
    return alert_manager

# alert_manager = example_alerting_system()
```

## Incident Management System

### Incident Response Framework

```python
# Incident Management System
from enum import Enum
from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional
from datetime import datetime
import uuid
import logging

class IncidentStatus(Enum):
    """Incident status"""
    OPEN = "open"
    INVESTIGATING = "investigating"
    IDENTIFIED = "identified"
    MONITORING = "monitoring"
    RESOLVED = "resolved"

@dataclass
class Incident:
    """Incident record"""
    incident_id: str
    title: str
    description: str
    severity: AlertSeverity
    status: IncidentStatus
    created_at: datetime
    updated_at: datetime
    resolved_at: Optional[datetime] = None
    assigned_to: Optional[str] = None
    alert_ids: List[str] = field(default_factory=list)
    timeline: List[Dict[str, Any]] = field(default_factory=list)
    
    def add_timeline_entry(self, action: str, details: str, user: str = None):
        """Add entry to incident timeline"""
        self.timeline.append({
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'details': details,
            'user': user
        })
        self.updated_at = datetime.now()
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            'incident_id': self.incident_id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity.value,
            'status': self.status.value,
            'created_at': self.created_at.isoformat(),
            'assigned_to': self.assigned_to,
            'alert_ids': self.alert_ids,
            'timeline_entries': len(self.timeline)
        }

class IncidentManager:
    """Incident management system"""
    
    def __init__(self, alert_manager: AlertManager):
        self.alert_manager = alert_manager
        self.incidents: Dict[str, Incident] = {}
        self.incident_history: List[Incident] = []
        self.logger = logging.getLogger(__name__)
    
    def create_incident(self, title: str, description: str, severity: AlertSeverity,
                       alert_ids: List[str] = None) -> str:
        """Create new incident"""
        incident_id = str(uuid.uuid4())
        
        incident = Incident(
            incident_id=incident_id,
            title=title,
            description=description,
            severity=severity,
            status=IncidentStatus.OPEN,
            created_at=datetime.now(),
            updated_at=datetime.now(),
            alert_ids=alert_ids or []
        )
        
        incident.add_timeline_entry("created", f"Incident created: {title}")
        
        self.incidents[incident_id] = incident
        self.incident_history.append(incident)
        
        self.logger.info(f"Created incident: {title}")
        return incident_id
    
    def update_incident_status(self, incident_id: str, status: IncidentStatus,
                              user: str = None) -> bool:
        """Update incident status"""
        if incident_id not in self.incidents:
            return False
        
        incident = self.incidents[incident_id]
        old_status = incident.status
        incident.status = status
        incident.updated_at = datetime.now()
        
        incident.add_timeline_entry(
            "status_change",
            f"Status changed from {old_status.value} to {status.value}",
            user
        )
        
        if status == IncidentStatus.RESOLVED:
            incident.resolved_at = datetime.now()
            del self.incidents[incident_id]
        
        self.logger.info(f"Incident {incident_id} status updated to {status.value}")
        return True
    
    def assign_incident(self, incident_id: str, assignee: str) -> bool:
        """Assign incident to user"""
        if incident_id not in self.incidents:
            return False
        
        incident = self.incidents[incident_id]
        incident.assigned_to = assignee
        incident.updated_at = datetime.now()
        
        incident.add_timeline_entry("assigned", f"Assigned to {assignee}")
        
        self.logger.info(f"Incident {incident_id} assigned to {assignee}")
        return True
    
    def auto_create_incidents(self):
        """Automatically create incidents from critical alerts"""
        critical_alerts = self.alert_manager.get_active_alerts(AlertSeverity.CRITICAL)
        emergency_alerts = self.alert_manager.get_active_alerts(AlertSeverity.EMERGENCY)
        
        for alert in critical_alerts + emergency_alerts:
            # Check if incident already exists for this alert
            existing_incident = None
            for incident in self.incidents.values():
                if alert.alert_id in incident.alert_ids:
                    existing_incident = incident
                    break
            
            if not existing_incident:
                incident_id = self.create_incident(
                    title=f"Critical Alert: {alert.title}",
                    description=f"Auto-created incident for alert: {alert.description}",
                    severity=alert.severity,
                    alert_ids=[alert.alert_id]
                )
                self.logger.info(f"Auto-created incident for alert {alert.alert_id}")
    
    def get_incident_statistics(self) -> Dict[str, Any]:
        """Get incident statistics"""
        total_incidents = len(self.incident_history)
        active_incidents = len(self.incidents)
        
        # Resolution times
        resolved_incidents = [i for i in self.incident_history if i.resolved_at]
        avg_resolution_time = 0
        if resolved_incidents:
            resolution_times = [
                (i.resolved_at - i.created_at).total_seconds() / 3600  # hours
                for i in resolved_incidents
            ]
            avg_resolution_time = sum(resolution_times) / len(resolution_times)
        
        return {
            'total_incidents': total_incidents,
            'active_incidents': active_incidents,
            'average_resolution_time_hours': avg_resolution_time,
            'resolved_incidents': len(resolved_incidents)
        }

# Example incident management
def example_incident_management():
    """Example of incident management system"""
    
    # Create alert manager and incident manager
    alert_manager = AlertManager()
    incident_manager = IncidentManager(alert_manager)
    
    # Add some alert rules
    critical_rule = AlertRule(
        rule_id='system_down',
        name='System Down',
        description='System is completely unavailable',
        condition='system_availability',
        severity=AlertSeverity.EMERGENCY,
        threshold_value=0.5,
        comparison_operator='<'
    )
    
    alert_manager.add_rule(critical_rule)
    
    # Trigger critical alert
    critical_metrics = {'system_availability': 0.2}
    alerts = alert_manager.evaluate_rules(critical_metrics)
    
    print(f"Triggered {len(alerts)} critical alerts")
    
    # Auto-create incidents
    incident_manager.auto_create_incidents()
    
    print(f"Active incidents: {len(incident_manager.incidents)}")
    
    # Show incident details
    for incident in incident_manager.incidents.values():
        print(f"Incident: {incident.title}")
        print(f"  Status: {incident.status.value}")
        print(f"  Severity: {incident.severity.value}")
        print(f"  Timeline entries: {len(incident.timeline)}")
    
    return alert_manager, incident_manager

# alert_manager, incident_manager = example_incident_management()
```

## Best Practices

### Alerting Best Practices

1. **Smart Alert Design**
   - Set appropriate thresholds to avoid alert fatigue
   - Implement alert correlation and deduplication
   - Use severity levels effectively
   - Include actionable information in alerts

2. **Escalation Procedures**
   - Define clear escalation paths
   - Implement time-based escalation
   - Ensure 24/7 coverage for critical systems
   - Maintain up-to-date contact information

3. **Incident Response**
   - Establish clear incident response procedures
   - Implement automated remediation where possible
   - Maintain comprehensive runbooks
   - Conduct post-incident reviews

4. **Continuous Improvement**
   - Regularly review and tune alert rules
   - Analyze alert patterns and trends
   - Update runbooks based on incidents
   - Train team members on response procedures

## Summary

Alerting and Incident Response provides:

- **Intelligent Alerting** - Smart alert rules with severity classification
- **Multi-channel Notifications** - Email, Slack, and other notification channels
- **Incident Management** - Comprehensive incident tracking and coordination
- **Automated Response** - Quick response to critical issues

Key components:
- Alert rule engine with threshold monitoring
- Multi-channel notification system
- Incident creation and tracking
- Timeline and status management

---

**Next**: Learn about [Performance Optimization](/chapters/monitoring-observability/performance-optimization) for system performance tuning.
