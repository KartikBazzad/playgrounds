import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import Playground from '@/pages/Playground';
import { getDB } from '@/lib/duckdb';

// Mock CodeMirror to a light component we can type into and fire keydown on
vi.mock('@uiw/react-codemirror', () => ({
  default: (props: any) => (
    <textarea
      aria-label="cm"
      value={props.value}
      onChange={(e) => props.onChange?.((e.target as HTMLTextAreaElement).value)}
      onKeyDown={props.onKeyDown}
      data-extensions={props.extensions ? '1' : '0'}
    />
  ),
}));

// Mock useRunner to control run() outputs and apply interpolation
const runMock = vi.fn();
let lastInterpolator: ((t: string) => string) | null = null;
vi.mock('@/lib/useRunner', () => ({
  useRunner: vi.fn((_refresh: any, interpolator?: (t: string) => string) => {
    lastInterpolator = interpolator || null;
    return {
      run: (sql: string) => runMock(lastInterpolator ? lastInterpolator(sql) : sql),
    };
  }),
}));

// Mock useSchema to observe refreshSchema calls and provide empty schema
export const refreshSchemaMock = vi.fn(async () => {});
vi.mock('@/lib/useSchema', () => ({
  useSchema: vi.fn(() => ({ schemaTables: [], schemaColumns: {}, refreshSchema: refreshSchemaMock })),
}));

// Provide stubs for DuckDB getDB to flip ready state
vi.mock('@/lib/duckdb', () => ({ getDB: vi.fn(async () => ({ connect: vi.fn(async () => ({ query: vi.fn(), close: vi.fn() })) })) }));

// Mock idb helpers
const idbGetMock: any = vi.fn();
const idbSetMock: any = vi.fn();
vi.mock('@/lib/idb', () => ({
  idbGet: (key: any) => idbGetMock(key),
  idbSet: (key: any, value?: any) => idbSetMock(key, value),
}));

// Clipboard
Object.assign(navigator, { clipboard: { writeText: vi.fn(async () => {}) } });

beforeEach(() => {
  idbGetMock.mockReset();
  idbSetMock.mockReset();
  runMock.mockReset();
  // Defaults after reset
  idbGetMock.mockImplementation(async () => undefined);
  idbSetMock.mockImplementation(async () => {});
});

describe('Playground flows', () => {
  it('single-editor: runs success and updates message/rows', async () => {
    // Force single-editor mode and preload SQL
    idbGetMock.mockImplementation(async (key: string) => {
      if (key === 'notebook_mode') return '0';
      if (key === 'playground_sql') return 'SELECT 1';
      return undefined;
    });
    runMock.mockResolvedValue({ columns: ['x'], rows: [{ x: 1 }], execMs: 3, message: 'Returned 1 rows' });

    render(<Playground />);

    // Wait for ready (Toolbar Run button enabled) and run
    const runBtn = await screen.findByLabelText('Run');
    fireEvent.click(runBtn);

    await waitFor(() => expect(screen.getByText('Returned 1 rows')).toBeTruthy());
  });

  it('copy SQL error path shows fallback message', async () => {
    idbGetMock.mockResolvedValue('0');
    const original = (navigator.clipboard.writeText as any);
    (navigator.clipboard.writeText as any) = vi.fn().mockRejectedValueOnce(new Error('no permission'));
    render(<Playground />);
    const btn = await screen.findByLabelText('Copy SQL');
    fireEvent.click(btn);
    await waitFor(() => expect(screen.getByText('Copy failed; select and copy manually')).toBeTruthy());
    (navigator.clipboard.writeText as any) = original;
  });

  it('vars panel: add/rename/remove and interpolation used on Run', async () => {
    // single-editor
    idbGetMock.mockResolvedValue('0');
    runMock.mockResolvedValue({ columns: [], rows: [], execMs: 1, message: 'ok' });
    render(<Playground />);
    // Show vars
    fireEvent.click(await screen.findByText('Show Vars'));
    // Add a var
    fireEvent.click(await screen.findByText('Add Var'));
    // There should be an input pair; rename autogenerated key (e.g., var1) and set value
    const keyInput = screen.getByDisplayValue(/var\d+/) as HTMLInputElement;
    fireEvent.change(keyInput, { target: { value: 'x' } });
    const valInput = screen.getAllByPlaceholderText('value')[0] as HTMLInputElement;
    fireEvent.change(valInput, { target: { value: '42' } });
    // Set SQL to use {{x}}
    const cm = await screen.findByLabelText('cm');
    fireEvent.change(cm, { target: { value: 'SELECT {{x}}' } });
    const runBtn = await screen.findByLabelText('Run');
    fireEvent.click(runBtn);
    await waitFor(() => expect(runMock).toHaveBeenCalled());
    // Assert interpolation applied
    const calledWith = (runMock.mock.calls[0] as any[])[0];
    expect(String(calledWith)).toContain('SELECT 42');
    // Remove var
    fireEvent.click(await screen.findByText('Remove'));
  });

  it('notebook: Alt+ArrowUp on first cell is a no-op (no toast)', async () => {
    idbGetMock.mockResolvedValue(undefined); // notebook by default
    render(<Playground />);
    // Send Alt+ArrowUp
    fireEvent.keyDown(window, { key: 'ArrowUp', altKey: true });
    // Ensure no move toast appears
    await new Promise((r) => setTimeout(r, 50));
    expect(screen.queryByText(/Moved cell (up|down)/i)).toBeNull();
  });

  it('more actions: Load Sample success shows message and refreshes schema', async () => {
    idbGetMock.mockResolvedValue('0');
    const okDb = { connect: vi.fn(async () => ({ query: vi.fn(), close: vi.fn(async () => {}) })) } as any;
    (getDB as unknown as { mockResolvedValueOnce: any }).mockResolvedValueOnce(okDb);
    render(<Playground />);
    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    fireEvent.click(await screen.findByText('Load Sample'));
    await waitFor(() => expect(screen.getByText('Sample loaded as table people')).toBeTruthy());
    await waitFor(() => expect(refreshSchemaMock).toHaveBeenCalled());
  });

  it('more actions: Load Sample error path shows error', async () => {
    idbGetMock.mockResolvedValue('0');
    const okDb = { connect: vi.fn(async () => ({ query: vi.fn(), close: vi.fn(async () => {}) })) } as any;
    (getDB as unknown as { mockResolvedValueOnce: any }).mockResolvedValueOnce(okDb);
    (getDB as unknown as { mockRejectedValueOnce: any }).mockRejectedValueOnce(new Error('sample fail'));
    render(<Playground />);
    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    fireEvent.click(await screen.findByText('Load Sample'));
    await waitFor(() => expect(screen.getByText(/sample fail/)).toBeTruthy());
  });
  

  it('more actions: install httpfs success shows message', async () => {
    idbGetMock.mockResolvedValue('0');
    render(<Playground />);
    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    fireEvent.click(await screen.findByText('Install httpfs'));
    await waitFor(() => expect(screen.getByText('httpfs installed and loaded')).toBeTruthy());
  });

  it('more actions: Parquet demo success shows rows and message', async () => {
    idbGetMock.mockResolvedValue('0');
    // Provide a result shape compatible with parquetDemo code path
    const res: any = {
      schema: { fields: [] },
      [Symbol.iterator]: function* () {},
    };
    const conn = {
      query: vi.fn(async (sql: string) => {
        if (/parquet_scan/.test(sql)) return res;
        return {};
      }),
      close: vi.fn(async () => {}),
    };
    (getDB as unknown as { mockResolvedValueOnce: any }).mockResolvedValueOnce({ connect: vi.fn(async () => conn) });
    const query = vi.fn()
      // First call: INSTALL/LOAD
      .mockResolvedValueOnce({})
      // Second call: SELECT * FROM parquet_scan ... LIMIT 5
      .mockResolvedValueOnce({
        schema: { fields: [{ name: 'a' }, { name: 'b' }] },
        // Minimal iterable rows with get(i)
        [Symbol.iterator]: function* () {
          const mkRow = (x: number) => ({ get: (i: number) => (i === 0 ? x : x + 1) });
          yield mkRow(1);
          yield mkRow(2);
        },
      });
    (getDB as unknown as { mockResolvedValueOnce: any }).mockResolvedValueOnce({
      connect: vi.fn(async () => ({ query, close: vi.fn(async () => {}) })),
    });

    render(<Playground />);
    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    fireEvent.click(await screen.findByText('Parquet demo'));
    await waitFor(() => expect(screen.getByText('Parquet demo: lineitem.parquet (5 rows)')).toBeTruthy());
  });

  it('more actions: Parquet demo error path shows error', async () => {
    idbGetMock.mockResolvedValue('0');
    // First getDB (mount) resolves, second (action) rejects
    const okDb = { connect: vi.fn(async () => ({ query: vi.fn(), close: vi.fn(async () => {}) })) } as any;
    (getDB as unknown as { mockResolvedValueOnce: any }).mockResolvedValueOnce(okDb);
    (getDB as unknown as { mockRejectedValueOnce: any }).mockRejectedValueOnce(new Error('parquet fail'));

    render(<Playground />);
    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    fireEvent.click(await screen.findByText('Parquet demo'));
    await waitFor(() => expect(screen.getByText(/parquet fail/)).toBeTruthy());
  });

  it('more actions: Reset DB success clears results and refreshes schema', async () => {
    idbGetMock.mockResolvedValue('0');
    // Ensure we have some rows first to clear
    runMock.mockResolvedValue({ columns: ['x'], rows: [{ x: 1 }], execMs: 1, message: 'ok' });
    render(<Playground />);
    const runBtn = await screen.findByLabelText('Run');
    fireEvent.click(runBtn);
    await waitFor(() => expect(screen.getByLabelText('Download CSV').getAttribute('disabled') == null).toBe(true));

    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    fireEvent.click(await screen.findByText('Reset'));
    await waitFor(() => expect(screen.getByText('Database reset (dropped people/adults/tips/lineitem)')).toBeTruthy());
    await waitFor(() => expect(refreshSchemaMock).toHaveBeenCalled());
  });

  it('more actions: Reset DB error path shows error', async () => {
    idbGetMock.mockResolvedValue('0');
    // First call (on mount) should resolve, second call (reset action) should reject
    const okDb = { connect: vi.fn(async () => ({ query: vi.fn(), close: vi.fn(async () => {}) })) } as any;
    (getDB as unknown as { mockResolvedValueOnce: any }).mockResolvedValueOnce(okDb);
    (getDB as unknown as { mockRejectedValueOnce: any }).mockRejectedValueOnce(new Error('reset fail'));
    render(<Playground />);
    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    fireEvent.click(await screen.findByText('Reset'));
    await waitFor(() => expect(screen.getByText(/reset fail/)).toBeTruthy());
  });

  it('datasets: load each dataset shows message and refreshes schema', async () => {
    idbGetMock.mockResolvedValue('0');
    render(<Playground />);
    const openDatasets = await screen.findByLabelText('Datasets');
    // People (local CSV)
    fireEvent.click(openDatasets);
    fireEvent.click(await screen.findByText('People (local CSV)'));
    await waitFor(() => expect(screen.getByText('Loaded dataset: people (local CSV)')).toBeTruthy());
    // Tips (remote CSV)
    fireEvent.click(openDatasets);
    fireEvent.click(await screen.findByText('Tips (remote CSV)'));
    await waitFor(() => expect(screen.getByText('Loaded dataset: tips (remote CSV)')).toBeTruthy());
    // TPCH Lineitem (Parquet) menu entry
    fireEvent.click(openDatasets);
    fireEvent.click(await screen.findByText('TPCH Lineitem (Parquet)'));
    await waitFor(() => expect(screen.getByText('Loaded dataset: lineitem (remote Parquet view)')).toBeTruthy());
    // refreshSchema should be called after each success
    await waitFor(() => expect(refreshSchemaMock).toHaveBeenCalled());
  });

  it('datasets: error path shows error message', async () => {
    idbGetMock.mockResolvedValue('0');
    // Cause refreshSchema to fail so loadDataset catch path triggers
    refreshSchemaMock.mockRejectedValueOnce(new Error('dataset boom'));
    render(<Playground />);
    const openDatasets = await screen.findByLabelText('Datasets');
    fireEvent.click(openDatasets);
    fireEvent.click(await screen.findByText('People (local CSV)'));
    await waitFor(() => expect(screen.getByText(/dataset boom/)).toBeTruthy());
  });

  it('copy SQL copies current editor text', async () => {
    idbGetMock.mockResolvedValue('0');
    render(<Playground />);
    const cm = await screen.findByLabelText('cm');
    fireEvent.change(cm, { target: { value: 'SELECT 1' } });
    const copyBtn = await screen.findByLabelText('Copy SQL');
    fireEvent.click(copyBtn);
    await waitFor(() => expect((navigator.clipboard.writeText as any)).toHaveBeenCalled());
  });

  it('download CSV enabled after run and triggers blob URL', async () => {
    idbGetMock.mockResolvedValue('0');
    runMock.mockResolvedValue({ columns: ['a'], rows: [{ a: 1 }], execMs: 1, message: 'ok' });
    const originalCreate = (URL as any).createObjectURL as any;
    let restore: (() => void) | null = null;
    let createUrlSpy: any;
    if (typeof originalCreate === 'function') {
      createUrlSpy = vi.spyOn(URL as any, 'createObjectURL').mockReturnValue('blob:csv');
      restore = () => createUrlSpy.mockRestore();
    } else {
      (URL as any).createObjectURL = vi.fn(() => 'blob:csv');
      createUrlSpy = (URL as any).createObjectURL as any;
      restore = () => { delete (URL as any).createObjectURL; };
    }
    render(<Playground />);
    // Run to produce rows
    const runBtn = await screen.findByLabelText('Run');
    fireEvent.click(runBtn);
    // Wait for CSV to become enabled
    await waitFor(() => expect(screen.getByLabelText('Download CSV').getAttribute('disabled') == null).toBe(true));
    const csvBtn = await screen.findByLabelText('Download CSV');
    fireEvent.click(csvBtn);
    await waitFor(() => expect(createUrlSpy).toHaveBeenCalled());
    restore && restore();
  });

  it('share link copies to clipboard and sets message', async () => {
    idbGetMock.mockImplementation(async (key: string) => (key === 'notebook_mode' ? '0' : undefined));
    render(<Playground />);
    const btn = await screen.findByLabelText('Share link');
    fireEvent.click(btn);
    await waitFor(() => expect((navigator.clipboard.writeText as any)).toHaveBeenCalled());
    await waitFor(() => expect(screen.getByText('Share link copied to clipboard')).toBeTruthy());
  });

  it('share link error path shows failure message', async () => {
    idbGetMock.mockImplementation(async (key: string) => (key === 'notebook_mode' ? '0' : undefined));
    const original = (navigator.clipboard.writeText as any);
    (navigator.clipboard.writeText as any) = vi.fn().mockRejectedValueOnce(new Error('clipboard blocked'));
    render(<Playground />);
    const btn = await screen.findByLabelText('Share link');
    fireEvent.click(btn);
    await waitFor(() => expect(screen.getByText('Failed to create share link')).toBeTruthy());
    (navigator.clipboard.writeText as any) = original;
  });

  it('save gist cancelled shows message', async () => {
    idbGetMock.mockResolvedValue('0');
    const promptSpy = vi.spyOn(window, 'prompt').mockReturnValueOnce('');
    render(<Playground />);
    const btn = await screen.findByLabelText('Save as Gist');
    fireEvent.click(btn);
    await waitFor(() => expect(screen.getByText('Gist cancelled')).toBeTruthy());
    promptSpy.mockRestore();
  });

  it('download CSV button is disabled when no results', async () => {
    idbGetMock.mockResolvedValue('0');
    render(<Playground />);
    const btn = await screen.findByLabelText('Download CSV');
    expect(btn.getAttribute('disabled') != null).toBe(true);
  });

  it('quality report triggers run in single-editor', async () => {
    idbGetMock.mockResolvedValue('0');
    runMock.mockResolvedValue({ columns: [], rows: [], execMs: 1, message: 'ok' });
    render(<Playground />);
    // Open more actions and click menu item
    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    const item = await screen.findByText(/quality report/i);
    fireEvent.click(item);
    await waitFor(() => expect(runMock).toHaveBeenCalled());
  });

  it('snippet apply in single-editor updates SQL', async () => {
    idbGetMock.mockResolvedValue('0');
    render(<Playground />);
    // Open snippets menu and click first snippet
    const sn = await screen.findByLabelText('Snippets');
    fireEvent.click(sn);
    const opt = await screen.findByRole('button', { name: /load sample/i });
    fireEvent.click(opt);
    const cm = await screen.findByLabelText('cm');
    await waitFor(() => expect((cm as HTMLTextAreaElement).value).toMatch(/LOAD SAMPLE/i));
  });

  it('#sql hash preloads editor', async () => {
    const orig = window.location.hash;
    const text = 'SELECT 42';
    const b64 = btoa(unescape(encodeURIComponent(text)));
    window.location.hash = `#sql=${encodeURIComponent(b64)}`;
    idbGetMock.mockResolvedValue('0');
    render(<Playground />);
    // When SQL updates from hash, persistence effect should write it to idb
    await waitFor(() => expect(idbSetMock.mock.calls.length).toBeGreaterThan(0));
    await waitFor(() => {
      const calls = idbSetMock.mock.calls as any[];
      const hit = calls.some((a) => {
        const args = a as any[];
        return Array.isArray(args) && args.length >= 2 && args[0] === 'playground_sql' && String(args[1]).includes('SELECT 42');
      });
      expect(hit).toBe(true);
    });
    window.location.hash = orig;
  });
  it('single-editor: run error shows error message', async () => {
    idbGetMock.mockImplementation(async (key: string) => (key === 'notebook_mode' ? '0' : undefined));
    runMock.mockRejectedValue(new Error('boom'));

    render(<Playground />);

    const runBtn = await screen.findByLabelText('Run');
    fireEvent.click(runBtn);

    await waitFor(() => expect(screen.getByText(/boom/)).toBeTruthy());
  });

  it('notebook: add, move, delete cells and runAll', async () => {
    // default notebook mode is true
    idbGetMock.mockResolvedValue(undefined);
    runMock.mockResolvedValue({ columns: ['a'], rows: [{ a: 1 }], execMs: 1, message: 'ok' });

    render(<Playground />);

    // Add cell below first
    const addBtn = await screen.findByLabelText('Add cell below');
    fireEvent.click(addBtn);
    await waitFor(() => expect(screen.getAllByLabelText('Delete cell').length).toBe(2));

    // Move first cell down
    const moveDown = screen.getAllByLabelText('Move down')[0];
    fireEvent.click(moveDown);
    await waitFor(() => expect(screen.getByText('Moved cell down')).toBeTruthy());

    // Run all
    const runAll = screen.getByLabelText('Run all');
    fireEvent.click(runAll);
    await waitFor(() => expect(runMock).toHaveBeenCalledTimes(2));

    // Delete a cell
    const del = screen.getAllByLabelText('Delete cell')[0];
    fireEvent.click(del);
    // There should be at least one cell remaining
    await waitFor(() => expect(screen.getAllByLabelText('Delete cell').length).toBeGreaterThan(0));
  });

  it('persists SQL changes to idb', async () => {
    // Start in notebook mode (default), then toggle to single-editor explicitly
    idbGetMock.mockImplementation(async () => undefined);
    render(<Playground />);

    // Toggle to single-editor
    const toggle = await screen.findByLabelText('Toggle mode');
    fireEvent.click(toggle);

    // Edit the editor textarea to trigger idbSet('playground_sql', ...)
    const cm = await screen.findByLabelText('cm');
    fireEvent.change(cm, { target: { value: 'SELECT 2' } });

    // Wait for any idbSet to occur (effect runs after state commit)
    await waitFor(() => expect(idbSetMock.mock.calls.length).toBeGreaterThan(0));
    await waitFor(() => {
      const hit = (idbSetMock.mock.calls as any[]).some((a) => {
        const args = a as any[];
        return args && args[0] === 'playground_sql' && args[1] === 'SELECT 2';
      });
      expect(hit).toBe(true);
    });
  });

  it('sqlLiteral branches: numbers, nulls, and strings with escaping interpolate correctly', async () => {
    // Force single-editor
    idbGetMock.mockResolvedValue('0');
    runMock.mockResolvedValue({ columns: [], rows: [], execMs: 1, message: 'ok' });
    render(<Playground />);
    // Open vars panel and add a var
    fireEvent.click(await screen.findByText('Show Vars'));
    fireEvent.click(await screen.findByText('Add Var'));
    const keyInput = screen.getByDisplayValue(/var\d+/) as HTMLInputElement;
    fireEvent.change(keyInput, { target: { value: 'x' } });
    const cm = await screen.findByLabelText('cm');

    const setVal = async (v: any) => {
      const valInput = screen.getAllByPlaceholderText('value')[0] as HTMLInputElement;
      fireEvent.change(valInput, { target: { value: v } });
      fireEvent.change(cm, { target: { value: 'SELECT {{x}}' } });
      const runBtn = await screen.findByLabelText('Run');
      runMock.mockClear();
      fireEvent.click(runBtn);
      await waitFor(() => expect(runMock).toHaveBeenCalled());
      return (runMock.mock.calls[0] as any[])[0] as string;
    };

    // number
    let sql = await setVal('3.14');
    expect(sql).toContain('SELECT 3.14');
    // integer
    sql = await setVal('42');
    expect(sql).toContain('SELECT 42');
    // string -> quoted
    sql = await setVal('abc');
    expect(sql).toContain("SELECT 'abc'");
    // contains single quote -> escaped
    sql = await setVal("O'Hara");
    expect(sql).toContain("SELECT 'O''Hara'");
    // literal 'null' (case-insensitive) -> NULL
    sql = await setVal('NuLl');
    expect(sql).toContain('SELECT NULL');
    // empty => treated as '' (string), not NULL
    sql = await setVal('');
    expect(sql).toContain("SELECT ''");
  });

  it('outside-click closes menus: More actions, Snippets, and Datasets', async () => {
    idbGetMock.mockResolvedValue('0');
    render(<Playground />);

    // More actions
    const more = await screen.findByLabelText('More actions');
    fireEvent.click(more);
    await screen.findByText('Reset');
    fireEvent.mouseDown(document.body);
    await waitFor(() => expect(screen.queryByText('Reset')).toBeNull());

    // Snippets
    const sn = await screen.findByLabelText('Snippets');
    fireEvent.click(sn);
    await screen.findByText(/load sample/i);
    fireEvent.mouseDown(document.body);
    await waitFor(() => expect(screen.queryByText(/load sample/i)).toBeNull());

    // Datasets
    const ds = await screen.findByLabelText('Datasets');
    fireEvent.click(ds);
    await screen.findByText(/People \(local CSV\)/i);
    fireEvent.mouseDown(document.body);
    await waitFor(() => expect(screen.queryByText(/People \(local CSV\)/i)).toBeNull());
  });

  it('notebook: applySnippet updates active cell (not global) and runs', async () => {
    // default is notebook mode
    idbGetMock.mockResolvedValue(undefined);
    runMock.mockResolvedValue({ columns: [], rows: [], execMs: 1, message: 'ok' });
    render(<Playground />);

    // Open snippets and apply "Load sample"
    const sn = await screen.findByLabelText('Snippets');
    fireEvent.click(sn);
    const opt = await screen.findByRole('button', { name: /load sample/i });
    fireEvent.click(opt);

    // First cell editor should contain the snippet text
    const cms = await screen.findAllByLabelText('cm');
    expect((cms[0] as HTMLTextAreaElement).value).toMatch(/LOAD SAMPLE/i);

    // Run via Run all (to avoid guessing per-cell run label)
    const runAll = screen.getByLabelText('Run all');
    fireEvent.click(runAll);
    await waitFor(() => expect(runMock).toHaveBeenCalled());
  });

  it('notebook: runAll executes cells in order', async () => {
    idbGetMock.mockResolvedValue(undefined);
    runMock.mockResolvedValue({ columns: [], rows: [], execMs: 1, message: 'ok' });
    render(<Playground />);

    // Add a second cell
    const addBtn = await screen.findByLabelText('Add cell below');
    fireEvent.click(addBtn);
    await waitFor(() => expect(screen.getAllByLabelText('cm').length).toBe(2));

    // Set SQL for each cell
    const cms = screen.getAllByLabelText('cm') as HTMLTextAreaElement[];
    fireEvent.change(cms[0], { target: { value: 'SELECT 1' } });
    fireEvent.change(cms[1], { target: { value: 'SELECT 2' } });

    // Run all and assert sequence
    runMock.mockClear();
    const runAll = screen.getByLabelText('Run all');
    fireEvent.click(runAll);
    await waitFor(() => expect(runMock).toHaveBeenCalledTimes(2));
    const first = (runMock.mock.calls[0] as any[])[0];
    const second = (runMock.mock.calls[1] as any[])[0];
    expect(String(first)).toContain('SELECT 1');
    expect(String(second)).toContain('SELECT 2');
  });
});
